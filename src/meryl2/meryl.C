
/******************************************************************************
 *
 *  This file is part of meryl, a genomic k-kmer counter with nice features.
 *
 *  This software is based on:
 *    'Canu' v2.0              (https://github.com/marbl/canu)
 *  which is based on:
 *    'Celera Assembler' r4587 (http://wgs-assembler.sourceforge.net)
 *    the 'kmer package' r1994 (http://kmer.sourceforge.net)
 *
 *  Except as indicated otherwise, this is a 'United States Government Work',
 *  and is released in the public domain.
 *
 *  File 'README.licenses' in the root directory of this distribution
 *  contains full conditions and disclaimers.
 */

#include "meryl.H"

//
//  Process each word on the command line:
//
//    Debug options and requests for help.
//     - dumpIndex
//     - dumpFile
//     - -h, -help, --help, help
//
//    Global options.  These are easier to do outside the command builder
//    (and besides, they're global options).
//      -k <kmer-size>
//      -l <label-size>
//      -m <mem-in-gb>    and -memory, --memory
//      -t <thread-limit> and -threads, --threads
//      -V, -VV, etc.
//  
//    Legacy options are k=<kmer-size>, memory=<mem-in-gb> and
//    threads=<thread-limit>.
//
//    If none of the above match, the usual case, toss the word to the
//    command builder and let it take care of it.
//
//  Once the command line has been scanned, finish building the command
//  trees, linking outputs to inputs, computing computable parameters, etc.
//  Then check for errors and display/fail if any are found.
//
//  Counting operations are a big headache.  They don't fit into the
//  tree nicely:
//   - they do their own threading, so only one thread can start the operation
//   - when done, they transform themselves into a pass-through operation that
//     simply reads the (just created) database and passes kmers through.
//
//  So, we special case them here.  This steps through each action in the tree,
//  counting kmers, writing to a new database, and finally converting the action
//  to a null pass-through.
//
//  Once counting is done, the action tree is expanded into 64 copies, one
//  for each database slice, that are run in parallel.  After the run,
//  deleting the commandBuilder will (recursively) delete all the action
//  nodes which will close and open files, etc.
//




//  Program text from an input file presents a challenge.  We need
//  to recognize and parse single and double quotes to allow
//  filenames with spaces.
//
//    output:database "file with spaces"
//    output:database "file'with'ticks"
//
//  Like appendProgramWords, 
void
merylCommandBuilder::loadProgramText(char const *f) {
  compressedFileReader  *cft = new compressedFileReader(f);

  bool        esc   = false;
  bool        quote = false;
  bool        tick  = false;

  while (cft->readLine() == true) {
    char const *line  = cft->line();
    uint32      lineL = cft->lineLen();

    for (uint32 ll=0; ll < lineL; ll++) {
      char  ch = line[ll];

      if      ((ch == '\\') && (esc == false)) {  //  Escape the next character.
        esc = true;
      }
      else if ((ch == '"') && (esc == false)) {   //  If a non-escaped quote, toggle
        quote = !quote;                           //  the quote-block state.
      }
      else {                                      //  See comments below about increaseArray().
        increaseArray(_pTxt, _pTxtLen+2, _pTxtMax, 16384);

        if ((quote == false) && (ch == ' '))      //  If not in a quote-block, and we see a
          ch = '\v';                              //  space, insert a word separator instead.

        _pTxt[_pTxtLen++] = ch;

        esc = false;
      }
    }
  }

  delete cft;

  _pTxt[_pTxtLen++] = '\v';
  _pTxt[_pTxtLen]   = '\0';
}


//  Words are separated by a vertical-tab, VT, \v.
//
//  Words are appended to the program text verbatim.  This will
//  pass filenames correctly, but will NOT pass quoted command
//  line options correctly:
//    meryl2 "output : database " <file>
//  but this is only a problem for malicious users, and we don't
//  support those.
//
void
merylCommandBuilder::appendProgramWord(char const *w) {

  if (w == nullptr)
    return;

  while (*w) {                                           //  Copy word to program text.
    increaseArray(_pTxt, _pTxtLen+2, _pTxtMax, 16384);   //  Get space for this letter and
    _pTxt[_pTxtLen++] = *w++;                            //  the '\n\0' terminating letters,
  }                                                      //  grabbing 16KB more as needed.

  _pTxt[_pTxtLen++] = '\v';
  _pTxt[_pTxtLen]   = '\0';
}


int
main(int argc, char **argv) {
  merylCommandBuilder  *B = new merylCommandBuilder;

  argc = globals.initialize(argc, argv);  //  Handles --version, initializes max memory and threads.

  std::vector<char const *>  err;
  for (int32 arg=1; arg < argc; arg++) {
    if ((globals.processDebugOption (arg, argv, err) == true) ||   //  The process() function
        (globals.processGlobalOption(arg, argv, err) == true))     //  handles the option;
      ;                                                            //  nothing for us to do.
#if 0
    else if (strcmp(argv[arg], "-p") == 0)
      B->loadProgramText(argv[++arg]);
#endif
    else
      B->appendProgramWord(argv[arg]);
  }

  B->processProgramText();

  exit(1);

  B->finalizeTrees();   //  Finalize the processing tree and check for errors.

  if ((argc == 1) ||                //  No commands
      (B->numTrees() == 0) ||       //  No actions
      (err.size() > 0)) {           //  Command line errors
    fprintf(stderr, "usage: %s ...\n", argv[0]);

#include "meryl-usage.H"

    for (uint32 ii=0; ii<err.size(); ii++)
      if (err[ii] != NULL)
        fprintf(stderr, "%s\n", err[ii]);

    exit(1);
  }

  if (B->displayTreesAndErrors() == true)  //  Halt on errors (and
    return 1;                             //  leak B).

  if (globals.stopAfterConfigure())  //  Print message and return success.
    return fprintf(stderr, "Stopping after configuration.\n"), 0;

  B->performCounting(globals.allowedMemory(), globals.allowedThreads());
  B->finalizeParameters();
  B->spawnThreads(globals.allowedThreads());
  B->runThreads(globals.allowedThreads());

  if (globals.showStandard() == true)
    fprintf(stderr, "\n"
                    "Cleaning up.\n");

  delete B;

  if (globals.showStandard() == true)
    fprintf(stderr, "\n"
                    "Bye.\n");
  return 0;
}
